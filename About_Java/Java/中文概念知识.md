#### 中文概念

##### 一、Java面向对象的四大特征

###### 封装

封装简单来说就是“屏蔽”，对外屏蔽功能的内部实现细节，提高代码的安全以及复用性。

###### 继承

客观世界中的父子关系，目的就是提高代码的复用性。
特点：

1. 子类可以继承其父类的所有非私有资源；
2. Java不支持多继承，但支持多重继承；
3. 假如子类觉得父类中的某些能力不满足现在的使用需要，就可以使用“重写”；若一个类中，完成类似的工作存在多种不同的实施方式，就可以使用“重载”；
4. 子类对象实例化需要先实例化父类，这是Java给人感觉比较占用内存的原因。

###### 多态

事物的多样性就称为多态，最大的好处是灵活。具体可表现为方法的重载和接口的多种实现。

###### 抽象

对子类做出一些约束，子类只有实现了父类的抽象方法，才能成功地继承父类。

##### 二、Java与字节流

###### 串行化 - 并行化：

串行化：也叫做序列化，就是把存在于内存的对象数据转化为可以保存成硬盘文件的形式去存储。
并行化：也叫反序列化，就是把序列化后的硬盘文件加载到内存，重新编程对象数据。

###### 序列化 - 反序列化：

当两个进程在进行远程通信时， 可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。发送方需要`把`这个`对象转换为字节序列（序列化）`，才能在网络上传送；而接收方则需要`把字节序列再恢复为对象（反序列化）`。
序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。`可以对流化后的对象进行读写操作（保存到硬盘），也可以将流化后的对象传输于网络之间`。序列化就是为了解决在对对象进行读写操作时所引发的问题。

###### 序列化的实现：

1. 被序列化的类需要实现`Serializable`接口（该接口没有需要实现的方法，实现该接口只是为了标注该对象是可被序列化的）；
2. 然后使用一个输出流（如：`FileOutputStream`）来构造一个`ObjectOutputStream`（对象流）对象；
3. 接着，使用`ObjectOutputStream`对象的`writeObject(Object obj)`方法就可以将参数为obj的对象写出（即保存其状态），要恢复的话则使用输入流。

##### 三、Java 常量池

Java 中的常量池实际上分为两种形态：静态常量池和运行时常量池。
静态常量池即是 *.class 文件中的常量池，用来存放方法名称、字段名称等。
运行时常量池则是我们常说的常量池，用来存放常量（final 关键字修饰的变量）和字符串等，避免频繁的创建和销毁对象而影响系统性能，实现了对象的共享（即大家用的都是同一个东西）。

**Java 常量池拓展：**

````java
String s1 = "Hello";
String s2 = new String("Hello");
String s3 = s2.intern();
String s4 = "Hel" + "lo";
String sa = "Hel";
String sb = "lo";
String s5 = sa + sb;

System.out.println(s1 == s2);// false
System.out.println(s1 == s3);// true
System.out.println(s1 == s4);// true
System.out.println(s1 == s5);// false
````

1. String 的 intern() 方法会查找在常量池中是否存在一份 equal 相等的字符串，如果有则返回该字符串的引用，如果没有则添加自己的字符串进入常量池。
   *(因为 s1 已经在常量池中创建了"Hello"字符串，所以 s2.intern() 的时候就去常量池中查找是否已经存在"Hello"，存在则直接=原来的字符串，不存在则是一个新的存在，所以 s3=s1)*
2. 虽然 s4 是动态拼接出来的，但所有参与拼接的部分都是已知的字面量，在编译期间，这种拼接会被优化，编译器直接帮你拼好，因此相等。
   *（只有使用这种全部带引号、使用“+”连接产生的新字符串对象才会被加入字符串池中）*
3. 虽然 s5 也是拼接，但 sa 和 sb 作为两个变量，都是不可预料的，并不会被优化，会存放到堆中。

##### 四、关联、依赖和泛化

关联、依赖和泛化都是 Java 类与类之间的关系。

* 关联：一个类在另外一个类里面当成员变量（扩展性好）

* 依赖：一个类在另外一个类的成员方法里面当参数或返回值，或者方法里面的局部变量

（优点：只能在一个区域内，方便查找，高内聚松耦合方便；缺点：不能扩展）

* 泛化：一个类继承另外一个类