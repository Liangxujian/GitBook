# 二叉树

### 一、二叉树遍历

![1558669458759](D:\GitBook\About_Database\assets\1558669458759.png)

1. 前序遍历
   根节点 -> 左节点 -> 右节点（ABCDEFGHK）
2. 中序遍历
   左节点 -> 根节点 -> 右节点（BDCAEHGKF）
3. 后序遍历
   左节点 -> 右节点 -> 根节点（DCBHKGFEA）

### 二、二叉树类型

#### 排序二叉树

排序二叉树是一种特殊结构的二叉树，可以非常方便地对树中所有节点进行排序和检索。
排序二叉树要么是一棵空二叉树，要么是具有下列性质的二叉树：
$$\begin{cases}若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值；
\\若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
\\它的左、右子树也分别为排序二叉树\end{cases}$$

![1558670251155](D:\GitBook\About_Database\assets\1558670251155.png)

#### 平衡二叉树（AVL树）

平衡二叉树是一种特殊的排序二叉树，它是一棵空树或者是具有以下性质的二叉树：
$$\begin{cases}左子树和右子树都是平衡二叉树；
\\左子树和右子树的深度（高度）之差的绝对值不超过1\end{cases}$$

![1558670463983](D:\GitBook\About_Database\assets\1558670463983.png)

#### 红黑树

红黑树是一种近似平衡的排序二叉树，需具有以下条件：
$$\begin{cases}每个节点或者是黑色，或者是红色；
\\根节点是黑色；
\\每个叶子节点是黑色 [注意：这里叶子节点，是指为空的叶子节点！]
\\如果一个节点是红色的，则它的子节点必须是黑色的；
\\从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点\end{cases}$$

![1558676278230](D:\GitBook\About_Database\assets\1558676278230.png)

红黑树的应用：
红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是 O(lgn)，效率非常之高。
例如：Java 集合中的 TreeSet 和 TreeMap，C++ STL 中的 set、map，以及 Linux 虚拟内存的管理，都是通过红黑树去实现的。

#### 红黑树和平衡二叉树

**红黑树并不是真正的平衡二叉树，但在实际应用中，红黑树的统计性能要高于平衡二叉树，但极端性能略差。**
由此我们可以得出结论：对于给定的黑色高度为 N 的红黑树，从根到叶子节点的最短路径长度为 N-1，最长路径长度为 2 * (N-1)。
提示：排序二叉树的深度直接影响了检索的性能，正如前面指出，当插入节点本身就是由小到大排列时，排序二叉树将变成一个链表，这种排序二叉树的检索性能最低：N 个节点的二叉树深度就是 N-1。
红黑树通过上面这种限制来保证它大致是平衡的——因为红黑树的高度不会无限增高，这样保证红黑树在最坏情况下都是高效的，不会出现普通排序二叉树的情况。
由于红黑树只是一个特殊的排序二叉树，因此对红黑树上的只读操作与普通排序二叉树上的只读操作完全相同，只是红黑树保持了大致平衡，因此检索性能比排序二叉树要好很多。
但**在红黑树上进行插入操作和删除操作会导致树不再符合红黑树的特征，因此插入操作和删除操作都需要进行一定的维护，以保证插入节点、删除节点后的树依然是红黑树。**