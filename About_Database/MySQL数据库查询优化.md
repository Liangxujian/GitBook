# MySQL 数据库查询优化

### 一、SQL语法优化

`（对于语法可使用explain关键字辨别慢查询）`

#### 1.1 避免查询冗余字段

尽量避免使用`select * from`和全表扫描，只查询需要的字段信息。减少数据的获取量，可减轻 IO 和网络的压力

#### 1.2 索引优化

考虑在`where`或`order by`涉及的列上建立索引，提高速度。
如果是多个字段的组合条件查询，则可考虑使用组合索引（查询一个组合索引比查询多个单索引快）；同时还要注意导致索引失效的情况

#### 1.3 避免索引失效

* 尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描
  最好不要给数据库留 NULL，尽可能的使用 NOT NULL 或者默认空字符串填充数据库（这里需注意：如果有空值的列是 char 型的，不管是不是空值它都会占用一定的空间，而 varchar 就不会）

* 尽量避免在 where 子句中使用!=或<>等比较符号，否则引擎将放弃使用索引而进行全表扫描

* 尽量避免在 where 子句中使用 or 来连接条件
  如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描

* `in`和`not in`要慎用，否则会导致全表扫描
  对于连续的数值，能用 between 就不要用 in；同时，用 exists 代替 in 也是一个选择
  下面是一个替换 in 的案例：

  ````sql
  SELECT * FROM table_a INNER JOIN (SELECT id FROM table_a LIMIT 10000, 200) t USING (id)
  ````

#### 1.4 使用 UNION 关键字代替 OR，然后对 SQL 语句进行分开调优

UNION 包含去重操作，UNION ALL 不会去重

### 二、数据库优化

#### 2.1 分表分区（物理层调优）

* 分表：大表拆小表，进行冷热分离（将大字段、访问频率低的字段拆分到单独的表中存储，分离冷热数据）
  这样处理有利于有效利用缓存，防止读入无用的冷数据，减少磁盘IO，同时保证热数据常驻内存提高缓存命中率
* 分区：将经常查询的表的数据文件单独放到较快的磁盘中，提高速度
* 历史数据分拆：将历史数据按照时间（或者其他字段）进行分拆，过时的放到历史表，业务表只存放最近的数据

#### 2.2 数据库集群

使用集群，利用多个数据库将业务分摊到不同的数据库，减轻单个数据库的压力
`（就是多买几个新的服务器，减轻单个的压力）`
`（这里可结合反向代理服务器Nginx和Redis进行负载均衡，其中会涉及数据和session同步的问题）`

#### 2.3 读写分离

利用主从结构，主数据库负责写，其他多个从数据库负责读（要避免多个写）

### 三、其他优化

使用Hibernate的二级缓存：要注意考虑二级缓存的命中率