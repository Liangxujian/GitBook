# Spring事务

### 一、Spring事务传播机制

从一个方法进入另外一个方法的时候，事务和另外一个方法的关系问题。
例如：
REQUIRED 就是两个方法用的都是同一个事务。
REQUIRES_NEW 就是新开一个事务。

事务的七种传播级别：

1. PROPAGATION_**REQUIRED**：
   默认的 Spring 事务传播级别，该级别的特点是：如果上下文中已经存在事务，那么就加入到事务中执行；如果当前上下文中不存在事务，则新建事务执行。该级别能满足处理大多数业务场景。
2. PROPAGATION_SUPPORTS：
   supprots，即是“支持”的意思。该级别的特点是：如果上下文存在事务，则支持事务加入事务；如果没有事务，则使用非事务的方式执行。该级别通常用来处理那些并非原子性的非核心业务逻辑操作，应用场景较少。
3. PROPAGATION_MANDATORY：
   该级别的事务要求上下文中必须要存在事务，否则抛出异常。配置该级别事务能够有效防止上下文调用代码时遗漏添加事务控制。比如一段代码不能单独被调用执行，但是一旦被调用，就必须有事务包含的情况，就可以使用这个传播级别。
4. PROPAGATION_**REQUIRES_NEW**：
   new，即是每次都要新建一个事务。该级别的特点是：每次都会新建一个事务，并且同时将上下文中的事务挂起，执行当前新建事务完成后，上下文事务恢复再执行。
   该事物用处挺大，例如当我们发红包之前，需要进行系统的初始化、验证、数据记录等操作，然后再发红包，然后记录发送日志，如果日志不准确，则整个父事务逻辑需要回滚。当配置了该事务后，发红包的子事务就不会影响到父事务的提交和回滚。
5. PROPAGATION_NOT_SUPPORTED：
   not supported，即是“不支持”的意思。该级别事务的特点是：如果上下文存在事务，则挂起事务，执行当前的逻辑，结束后再恢复上下文的事务。
   该级别事务的好处就是将事务极可能缩小，降低了事务的风险。
6. PROPAGATION_NEVER：
   该事务更加严格，要求上下文中不能存在事务，否则就会报 runtime 异常，强制停止执行。
7. PROPAGATION_NESTED：
   nested，嵌套级别事务。该级别事务的特点是：如果上下文中存在事务，则嵌套事务执行；如果不存在事务，则新建事务。
   在该级别事务中，父事务会在进入子事务之前，建立一个 save point 的回滚点，子事务会回滚到这个回滚点，父事务之前的操作不受影响；而父事务则会连带子事务一并回滚，子事务不会提交。子事务是父事务的一部分，由父事务统一提交。

### 二、Spring事务隔离级别

1. Serializable：最严格的级别，事务串行执行，资源消耗最大。
2. REPEATABLE READ：保证了一个事务不会修改已经由另一个事务读取但未提交（回滚）的数据。避免了“脏读”和“不可重复读”，但是带来了更多的性能损失。
3. READ COMMITTED：大多数主流数据库的默认事务等级，保证了一个事务不会读到另一个并行事务已修改但仍未提交的数据，避免了“脏读”。该级别适用大多数系统。
4. Read Uncommitted：保证了读取过程中不会读取到非法数据。

关系对照表

![1562836092081](D:/GitBook/About_Java/Spring/assets/1562836092081.png)

|                  | 脏读<br>Dirty reads | 不可重复读<br>no-repeatable reads | 幻读<br>phantom |
| ---------------- | ------------------- | --------------------------------- | --------------- |
| Serializable     | ×                   | ×                                 | ×               |
| REPEATABLE READ  | ×                   | ×                                 | √               |
| READ COMMITTED   | ×                   | √                                 | √               |
| Read Uncommitted | √                   | √                                 | √               |

* 脏读：
  就是读到了别的事务回滚前的脏数据。
  例如事务 B 执行过程中修改了数据 X，在未提交前，事务 A 也读取了 X，但事务 B 却回滚了，这样事务 A 就形成了脏读。

* 不可重复读：
  例如事务 A 先读取了一条数据，然后再执行逻辑的时候，事务 B 将这条数据改变了，然后事务 A 再次读取该数据，发现数据不匹配，这就是所谓的不可重复读。

* 幻读：
  例如事务 A 先根据条件索引得到10条数据，然后事务 B 改变了数据库的一条数据，导致也符合事务 A 当时的搜索条件，这样事务 A 再次搜索发现有11条数据了，就产生了幻读。