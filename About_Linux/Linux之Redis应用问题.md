# Linux 之 Redis 应用问题

> 本篇笔记摘录自博客：[REDIS缓存穿透,缓存击穿,缓存雪崩原因+解决方案](https://www.cnblogs.com/xichji/p/11286443.html)

## 一、问题描述

- 缓存穿透：key 对应的数据在数据源并不存在，每次针对此 key 的请求从缓存获取不到，请求都会到数据源，从而可能压垮数据源。比如用一个不存在的用户 ID 获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。
- 缓存击穿：key 对应的数据存在，但在 Redis 中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端 DB 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 DB 压垮。
- 缓存雪崩：当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统（比如 DB）带来很大压力。

## 二、问题处理方案

### 2.1 缓存穿透处理方案

一个一定不存在缓存及查询不到的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。

有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用**布隆过滤器**，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被 这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法：**如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果在代码中缓存到 Redis，但它的过期时间会很短，最长不超过五分钟**。

### 2.2 缓存击穿处理方案

key 可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题。

**使用互斥锁（mutex key）**

业界比较常用的做法，是使用 mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去 load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如 Redis 的 SETNX 或者 MemCache 的 ADD）去 set 一个 mutex key，当操作返回成功时，再进行 load db 的操作并回设缓存；否则，就重试整个 get 缓存的方法。

SETNX，是「SET if Not eXists」的缩写，也就是在指定的 key 不存在时，为 key 设置指定的值，可以利用它来实现锁的效果。

````java
public String get(key) {
    String value = redis.get(key);
    if (value == null) { // 代表缓存值过期
        // 设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db
        if (redis.setnx(key_mutex, 1, 3 * 60) == 1) {  // 代表设置成功
            value = redis.get(key);
            redis.set(key, value, expire_secs);
            redis.del(key_mutex);
        } else {  // 这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可
            sleep(50);
            value = redis.get(key);  // 重试
        }
    }
    return value;
}
````

MemCache 代码

````java
String value = memcache.get(key);
if (value == null) {
    // 3 min timeout to avoid mutex holder crash
    if (memcache.add(key_mutex, 3 * 60 * 1000) == true) {
        value = memcache.get(key);
        memcache.set(key, value);
        memcache.delete(key_mutex);
    } else {
        sleep(50);
        value = memcache.get(key);
    }
}
return value;
````

### 2.3 缓存雪崩处理方案

与缓存击穿的区别在于这里针对很多 key 缓存，前者则是某一个 key。

Redis 正常获取缓存示意图：
![Redis 正常获取缓存示意图](assets\image-20201126155024089.jpg)

Redis 缓存失效瞬间示意图：
![Redis 缓存失效瞬间示意图](assets\image-20201126165024089.jpg)

缓存失效时的雪崩效应对底层系统的冲击非常可怕！大多数系统设计者考虑用**加锁或者队列的方式来保证不会出现大量线程对数据库一次性进行读写的情况**，从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就是**将缓存失效时间分散开**，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。

加锁排队只是为了减轻数据库的压力，并没有提高系统吞吐量。假设在高并发下，缓存重建期间 key 是锁着的，这是过来1000个请求999个都在阻塞的。同样会导致用户等待超时，这是个治标不治本的方法！

注意：加锁排队的解决方式在分布式环境中，有可能还要解决分布式锁的问题；线程还会被阻塞，用户体验很差！因此，在真正的高并发场景下很少使用！

**解释说明：**

- 缓存标记：记录缓存数据是否过期，如果过期会触发通知另外的线程在后台去更新实际 key 的缓存；
- 缓存数据：它的过期时间比缓存标记的时间延长1倍，例：标记缓存时间30分钟，数据缓存设置为60分钟。这样，当缓存标记 key 过期后，实际缓存还能把旧数据返回给调用端，直到另外的线程在后台更新完成后，才会返回新缓存。

关于缓存崩溃的解决方法，这里提出了三种方案：使用锁或队列、设置过期标志更新缓存、为 key 设置不同的缓存失效时间，还有一种被称为“二级缓存”的解决方法。