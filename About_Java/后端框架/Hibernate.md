#### Hibernate

##### 一、关于 Hibernate 框架

Hibernate 是一个 ORM 框架（对象关系映射）

##### 二、Hibernate 的一二级缓存

###### 一级缓存（内部缓存）：

一级缓存属于应用事务级缓存，也即“Session 的缓存”。
*之所以说是应用事务级缓存，因为 Session 对象的生命周期通常对应一个数据库事务或一个应用事务。*

###### 二级缓存（“SessionFactory 缓存”）：

SessionFactory 对象的生命周期与应用程序的整个过程对应，因此 Hibernate 二级缓存是进程范围或者集群范围的缓存有可能出现并发问题，需采用适当的并发访问策略，为被缓存的数据提供事务隔离级别。
二级缓存是可选的，是一个可配置的插件，默认情况下 SessionFactory 不会开启。

不适合存放二级缓存的数据：
① 经常被修改的数据
② 绝对不允许出现并发的数据（如财务数据）
③ 与其他应用共享的数据

一级缓存，也叫做“Session 缓存”，其生命周期通常对应一个数据库事务或一个应用事务。
二级缓存，也叫做“SessionFactory 缓存”，其生命周期与应用程序的整个过程对应。

##### 三、Hibernate 缓存机制的作用流程

当 Hibernate 根据 ID 访问数据对象的时候，会先从 Session 一级缓存中查；
查不到，如果配置了二级缓存的话，则会到二级缓存中查；
如果都查不到，再去查数据库，把结果按照 ID 放到缓存中。当有增删改操作的时候，更新缓存。

##### 四、Hibernate 的三种状态

|                           | 临时态 | 持久态 | 游离态 |
| ------------------------- | :----: | :----: | :----: |
| 是否存在 session 的缓存中 |   √    |   √    |   ×    |
| 是否在数据表中有对应记录  |   ×    |   √    |   √    |

###### 临时态（瞬时态）

**通过new关键字生产一个实体对象，即是临时态。**此时对象还未纳入Hibernate的缓存管理中（没有 session 关联），该状态的特点是——**在数据库中不存在一条与之对应的记录**。如果没有变量引入这个对象，则会被 JVM 的垃圾回收机制回收。

###### 持久态

通过 Session 的 save()、saveOrUpdate()、persist()、merge() 方法，进行对象的持久化。**持久化对象是已经被保存进数据库的实体对象，在数据库中有对应的记录，拥有一个持久化标识（ID），并且这个实体对象现在还处在 Hibernate 的缓存管理之中（session 还未关闭）。**对该实体对象的任何修改，并不会马上同步到数据库，直到数据库事务提交。

###### 游离态

当 Session 进行了 close()、clear()、evict() 或 flush() 后（session 关闭），实体对象从持久态变成游离态，对象虽然拥有持久和与数据库对应记录一致的标识值，但对象已从会话中清除，不在持久化管理之内。**此状态与临时态十分相似，但多了一个持久化的标识。**

![1562921301949](D:\GitBook\About_Java\后端框架\assets\1562921301949.png)

##### 五、Hibernate 和 MyBatis 的区别

###### 对数据库操作方面

Hibernate 入门门槛高，是一个标准的 ORM 框架（对象关系映射），不需要程序写 SQL，SQL 语句自动生成，但是对 **SQL 语句进行优化、修改比较困难**；
MyBatis 专注于 SQL 本身，需要程序员自己编写 SQL，**SQL 修改、优化比较方便**。是一个不完全的 ORM 框架，虽然程序员自己写 SQL，MyBatis 也可以实现映射（输入映射，输出映射）。

###### 应用场景方面

**Hibernate 适用于需求变化不多的中小型项目**，比如：后台管理系统，ORM、OA 等；
**MyBatis 适用于需求变化较多的项目**，比如：互联网项目。