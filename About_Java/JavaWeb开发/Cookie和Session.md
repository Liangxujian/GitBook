# Cookie 和 Session

> 本篇笔记部分参考自博客：[你真的了解 Cookie 和 Session 吗?](https://www.cnblogs.com/ityouknow/p/10856177.html)

什么是 Cookie？什么是 Session？这两者的区别是什么？

### 一、什么是 Cookie

HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）**是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。**通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。

Cookie 主要用于以下三个方面：

- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- 个性化设置（如用户自定义设置、主题等）
- 浏览器行为跟踪（如跟踪分析用户行为等）

### 二、什么是 Session

Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。

### 三、Cookie 和 Session 的区别

- 作用范围不同，Cookie 保存在客户端（浏览器），Session 保存在服务器端。
- 存取方式的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。
- 有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。
- 隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。
- 存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。

### 四、Cookie 和 Session 在使用时的关联

![1563762638165](D:\GitBook\About_Java\JavaWeb开发\assets\1563762638165.png)

用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建创建对应的 Session ，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。

当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。

根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。

### 五、用户浏览器禁止 Cookie 后的处理方案

* 方案一

  每次请求中都携带一个 SessionID 的参数，也可以 Post 的方式提交，也可以在请求的地址后面拼接 `xxx?SessionID=123456...`。

* 方案二

  Token 机制。

  Token 的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。Token 机制和 Cookie 和 Session 的使用机制比较类似。

  当用户第一次登录后，服务器根据提交的用户信息生成一个 Token，响应时将 Token 返回给客户端，以后客户端每次请求只需带上这个 Token 前来请求数据即可，无需再次登录验证。

### 六、分布式 Session 问题

有些 JavaWeb 项目为了可以支撑更大的流量，在后端往往配置了多台服务器共同来支撑前端用户请求，这时需处理解决：用户在 A 服务器登录，但是第二次请求跑到 B 服务器，导致出现登录失效问题。

分布式 Session 一般会有以下几种解决方案：

- 方案一：Nginx ip_hash 策略

  服务端使用 Nginx 代理，每个请求按访问 IP 的 hash 分配，这样来自同一 IP 固定访问一个后台服务器，避免了在服务器 A 创建 Session，第二次分发到服务器 B 的现象。

- 方案二：Session 复制

  在任何一个服务器上的 Session 信息发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。

- 方案三：共享 Session

  将用户的 Session 等信息使用缓存中间件（Redis）来统一管理，保障分发到每一个服务器的响应结果都一致。

  Redis 是基于内存存储数据的，性能很高，尤其是高并发的情况下尤为合适。主要是因为从内存中读取数据要比从磁盘读取数据快很多。

  而且 Redis 内存数据库还支持数据过期失效的机制，正好与 Session 的过期机制对应。且支持内存数据备份到磁盘。

由于内存存储数据的高性能和高适用性，因此推荐使用方案三。