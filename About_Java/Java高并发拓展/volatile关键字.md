# volatile 关键字

本篇笔记参考自博客：https://www.jianshu.com/p/7798161d7472

> volatile 关键字经常在并发编程中使用，其特性是保证可见性以及有序性，但是关于 volatile 的使用仍然要小心，这需要明白 volatile 关键字的特性及实现的原理，这也是本篇文章的主要内容。

#### 一、Java 内存模型

先形成基础认识，了解下 Java 内存模型。

Java内存模型规定了：

* **所有的变量都存储在主内存中**
* **每条线程中还有自己的工作内存，线程的工作内存中保存了被该线程所使用到的变量**
  （这些变量是从主内存中拷贝而来）
* **线程对变量的所有操作（读取，赋值）都必须在工作内存中进行**
* **不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成**

![8a3d9a1b94b97e83](D:\GitBook\About_Java\Java高并发拓展\assets\8a3d9a1b94b97e83.png)

由此可预知，当我们进行多线程编程时，变会产生数据“脏读”等问题。

举个例子：

````java
int i = 10;
````

**执行线程需要先在自己的工作线程中对变量 i 所在的缓存行进行赋值操作，然后再写入主存当中。**

而此时同时有两个线程执行这段代码，i 的初始值为 10，但是我们希望这两个线程执行完后，i 的值可以变为 12。

这时可能存在下面一种情况：

**初始时，两个线程分别读取 i 的值存入各自所在的工作内存中，接着线程1 进行 +1 操作，然后把 i 的最新值写入到内存。此时线程2 的工作内存当中 i 的值还是 10，也进行 +1 操作后，线程2 把 i 的值也写入到内存。**

这时最终的结果是 i = 11，而不是 12。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为：**共享变量**。

我们要让 i = 12，就要解决共享变量的正确性问题，需要先了解并发编程的三大概念：**原子性，有序性，可见性**。

#### 二、原子性

##### 2.1 定义

原子性：即一个操作或者多个操作，要么全部执行，并且执行的过程不会被任何因素打断，要么就都不执行。

##### 2.2 实例

银行转账中途停电问题

##### 2.3 Java 中的原子性

在 Java 中，**对基本数据类型的变量的读取和赋值操作是原子性操作**，即这些操作是不可被中断的，要么执行，要么不执行。

案例理解：

````java
x = 10;    //语句1
y = x;     //语句2
x++;       //语句3
x = x + 1; //语句4
````

在上面的四个语句中，只有语句1 是原子性操作，其他三个都不是。

语句1 是直接将数值 10 赋值给 x，也就是说线程执行这个语句的会直接将数值 10 写入到工作内存中。

语句2 实际上包含两个操作，它先要去读取 x 的值，再将 x 的值写入工作内存。虽然``读取 x 的值``，以及``将 x 的值写入工作内存``，这2个操作都是原子性操作，但是合起来就不是原子性操作了。

同样的，**语句3（x++）和语句4（x = x+1）包括三个操作：读取 x 的值，进行 +1 操作，写入新的值**。

因此，**只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。**

Java 内存模型只保证了基本读取和赋值是原子性操作，**如果要实现更大范围操作的原子性，可以通过 synchronized 和 Lock 来实现。由于 synchronized 和 Lock 能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。**

#### 三、可见性

##### 3.1 定义

可见性：即当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

##### 3.2 实例

````java
//线程1执行的代码
int i = 0;
i = 10;
 
//线程2执行的代码
j = i;
````

由上面的分析可知，当线程1 执行 i =10 时，会先把i的初始值加载到工作内存中，然后赋值为 10，那么在线程1 的工作内存当中 i 的值变为 10 了，却没有立即写入到主存当中。

此时线程2 执行 j = i，它会先去主存读取 i 的值并加载到线程2 的工作内存当中，注意此时内存当中i的值还是 0，那么就会使得 j = 0，而不是 10.

这就是可见性问题，线程1 对变量i修改了之后，线程2 没有立即看到线程1 修改的值。

##### 3.3 Java 中的可见性

对于可见性，Java 提供了 volatile 关键字。

**当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。**

而普通的共享变量不能保证可见性，**是因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。**

另外，通过 synchronized 和 Lock 也能够保证可见性，synchronized 和 Lock 能保证同一时刻只有一个线程获取锁然后执行同步代码，并且**在释放锁之前会将对变量的修改刷新到主存当中**。因此可以保证可见性。

#### 四、有序性

##### 4.1 定义

有序性：即程序执行的顺序按照代码的先后顺序执行。

##### 4.2 实例

````java
int i = 0;              

boolean flag = false;

i = 1;                //语句1  
flag = true;          //语句2
````

例子中的语句1 并不一定会在语句2 之前执行（虽然看起来是这样），因为这里可能会有指令重排（Instruction Reorder）的现象。

指令重排：**一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。**
（简单来说就是：①处理器进行代码优化；②优化处理会考虑指令之间的数据依赖性，不会影响到程序的最终逻辑）

**指令重排在单个线程内不会影响到程序执行的结果，但是会影响到线程并发执行的正确性**：

````java
//线程1:
context = loadContext();   //语句1
inited = true;             //语句2

//线程2:
while(!inited ){
   sleep()
}
doSomethingwithconfig(context);
````

在上面代码中，由于语句1 和语句2 没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1 执行过程中先执行语句2，而此是线程2 会以为初始化工作已经完成，那么就会跳出 while 循环，去执行 doSomethingwithconfig(context) 方法，但此时 context 并没有被初始化，就会导致程序出错。

由此得出一个结论：**要想并发程序正确地执行，就必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。**

##### 4.3 Java 中的有序性

由于在 Java 内存模型中，允许编译器和处理器对指令进行重排序，会影响到多线程并发执行的正确性。

因此我们可以使用 volatile 关键字来保证一定的“有序性”。另外，也可使用 synchronized 和 Lock。因为 synchronized 和 Lock 能保证每个时刻是只有一个线程在执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。

Java 内存模型具备一些先天的“有序性”，即 Java 处理器能够维护单个线程的执行结果，这种处理称为：先行发生（happens-before）原则。**如果两个操作的执行次序无法从 happens-before 原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。**

先行发生（happens-before）原则：

1. **程序次序规则**：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作
   （该规则无法保证程序在多线程中执行的正确性）
2. **锁定规则**：一个 unLock 操作先行发生于后面对同一个锁的 lock 操作
   （先解锁，必须要先上锁；或者是，要上锁，必须要等程序先解锁）
3. **volatile 变量规则**：对一个 volatile 关键字修饰的变量的写操作先行发生于后面对这个变量的读操作
4. **传递规则**：如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C
   （该规则体现了 happens-before 原则具有传递性）
5. 线程启动规则：Thread 对象的 start() 方法，先行发生于此线程的每一个动作
6. 线程中断规则：对线程 interrupt() 中断方法的调用，先行发生于被中断线程的代码检测到中断事件的发生
7. 线程终结规则：线程中所有的操作，都先行发生于线程的终止检测，我们可以通过 Thread.join() 方法结束、Thread.isAlive() 方法的返回值，来检测线程是否已经终止执行
8. 对象终结规则：一个对象的初始化完成，先行发生于他的 finalize() 释放内存方法的开始

以上 8 条规则中，前 4 条规则比较重要，后 4 条规则都是显而易见的。

#### 五、深入理解 volatile 关键字

##### 5.1 volatile 保证可见性

一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：

1. 保证了**不同线程对这个变量进行操作时的可见性**
   （即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的）
2. **禁止进行指令重排序**

````java
//线程1
boolean stop = false;
while(!stop){
    doSomething();
}
 
//线程2
stop = true;
````

以上这段代码中，我们先执行线程1，然后执行线程2。

这时虽然理解上是，一旦执行线程2，变量 stop 的值就会发生改变，循环就会被中断。但是也会出现线程无法中断的情况（虽然是小概率，但是一旦发生，程序即陷入死循环）。

因为就算线程2 更改了 stop 变量的值，但是还没来得及写入主存当中，线程2 就转去做其他事情了，那么线程1 由于不知道线程2 对 stop 变量的更改，因此还会一直循环下去。

但是用 volatile 关键字进行修饰的话就不一样了：

1. volatile 关键字会**强制将线程2 修改的值立即写入主内存**
2. volatile 关键字会**在线程2 进行修改时，使得线程1 的工作内存中缓存变量 stop 的缓存行无效**
   （反映到硬件层的话，就是 CPU 的 L1 或者 L2 缓存中对应的缓存行无效）
3. 由于线程1 的工作内存中缓存变量 stop 的缓存行无效了，所以**线程1 再次读取变量 stop 的值时只能主内存找**

##### 5.2 volatile 不保证原子性

````java
public class Test {
    public volatile int inc = 0;
     
    public void increase() {
        inc++;
    }
     
    public static void main(String[] args) {
        final Test test = new Test();
        for(int i=0;i<10;i++){
            new Thread(){
                public void run() {
                    for(int j=0;j<1000;j++)
                        test.increase();
                };
            }.start();
        }
         
        while(Thread.activeCount()>1)  //保证前面的线程都执行完
            Thread.yield();
        System.out.println(test.inc);
    }
}
````

以上程序在理解上执行的结果为：test.inc = 10 * 1000 = 10000

但是在实际的运行中，会发现每次运行结果都不一致，都是一个小于 10000 的数字。

这种情况跟 volatile 关键字不保证原子性有关：

假如某个时刻中，inc 的值为 10。**线程1 要对变量进行自增操作，线程1 先读取了主内存的值，得到 inc = 10，然后立马转去做其他事了（这里要注意的是：线程1 并没有对inc 进行修改，因此不会导致线程2 的工作内存中缓存变量 inc 的缓存行无效，也不会导致主内存中的值刷新）。**这时，线程2 也要对变量进行自增操作，直接去主内存拿到 inc = 10，然后进行 +1 操作得到 11，并写到了主内存中。然后线程1 有空闲回来继续操作的时候，也是对原来的 10 进行 +1 操作，写到主内存中。

那么两个线程分别都进行了一次自增操作，但是 inc 只增加了 1。其根源就在于：**volatile 关键字不保证原子性**。这里可通过：**synchronized 或 lock，进行加锁处理，来保证操作的原子性。也可以通过 AtomicInteger。**

##### 5.3 volatile 保证有序性

由于 volatile 关键字能禁止指令重排序，所以 volatile 能在一定程度上保证有序性。（回看：volatile 变量规则）

这里继续使用有序性的例子：

````java
//线程1:
context = loadContext();   //语句1
inited = true;             //语句2
 
//线程2:
while(!inited){
  sleep()
}
doSomethingwithconfig(context);
````

这里可知语句2 可能会在语句1 之前执行，导致线程1 在初始化语句2 后离开做其他事，没有初始化 context；而线程2 中使用未初始化的context去进行操作，程序出错。

如果使用 volatile 关键字对 inited 变量进行修饰，就不会出现这种问题。因为语句2 的初始化必定在语句1 后执行

#### 六、volatile 的实现原理

##### 6.1 可见性

处理器为了提高处理速度，不直接和内存进行通讯，而是将系统内存的数据独到内部缓存后再进行操作，但操作完后不知什么时候会写到内存。

但是如果是**对声明了 volatile 变量进行写操作的时候，JVM 会向处理器发送一条 Lock 前缀的指令，将这个变量所在缓存行的数据写会到系统内存。** 这一步确保了如果有其他线程对声明了 volatile 变量进行修改，会立即更新主内存中的数据。

而这时候其他处理器的缓存还是旧的，所以在多处理器环境下，为了保证各个处理器缓存一致，**每个处理会通过嗅探在总线上传播的数据来检查自己的缓存是否过期，当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作时，会强制重新从系统内存把数据读到处理器缓存里。**这一步确保了其他线程获得的声明了 volatile 变量都是从主内存中获取最新的。



作者：Ruheng
链接：https://www.jianshu.com/p/7798161d7472
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

##### 6.2 有序性

Lock 前缀指令实际上相当于一个内存屏障（也成内存栅栏），它确保**指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；**即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。